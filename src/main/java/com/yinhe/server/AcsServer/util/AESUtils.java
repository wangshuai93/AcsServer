/***************************************************************************
 *                                                                         *
 * Auto Generated BY CodeComment                                           *
 * Copyright(C) 2000-2016, JiangSu Yinhe Electronic Co.Ltd.                *
 * All Rights Reserved.                                                    *
 * THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Yinhe Elec Co.Ltd.       *
 * The copyright notice above does not evidence any actual or intended     *
 * publication of such source code.                                        *
 *                                                                         *
 **************************************************************************/


package com.yinhe.server.AcsServer.util;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

import com.yinhe.server.AcsServer.types.YMD;

public class AESUtils {
	  /**
     * 加密
     * 
     * @param content 需要加密的内容
     * @param password  加密密码
     * @return
     */
    public static byte[] encrypt(String plain, String keyHex) {
            try {           
            		byte[] byteKey = parseHexStr2Byte(keyHex);
            		SecretKeySpec key = new SecretKeySpec(byteKey, "AES");
                    Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");// 创建密码器
                    byte[] byteContent = parseHexStr2Byte(plain);
                    cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
                    byte[] result = cipher.doFinal(byteContent);
                    return result; // 加密
            } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                    e.printStackTrace();
            } catch (InvalidKeyException e) {
                    e.printStackTrace();
            } catch (IllegalBlockSizeException e) {
                    e.printStackTrace();
            } catch (BadPaddingException e) {
                    e.printStackTrace();
            }
            return null;
    }
    
    /**解密
     * @param content  待解密内容
     * @param password 解密密钥
     * @return
     */
    public static byte[] decrypt(byte[] cipherData, String keyHex) {
            try {
            		byte[] byteKey = parseHexStr2Byte(keyHex);
        			SecretKeySpec key = new SecretKeySpec(byteKey, "AES");
                    Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");// 创建密码器
                    cipher.init(Cipher.DECRYPT_MODE, key);// 初始化
                    byte[] result = cipher.doFinal(cipherData);
                    return result; // 加密
            } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                    e.printStackTrace();
            } catch (InvalidKeyException e) {
                    e.printStackTrace();
            } catch (IllegalBlockSizeException e) {
                    e.printStackTrace();
            } catch (BadPaddingException e) {
                    e.printStackTrace();
            }
            return null;
    }
    
    /**将二进制转换成16进制
     * @param buf
     * @return
     */
    public static String parseByte2HexStr(byte buf[]) {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < buf.length; i++) {
                    String hex = Integer.toHexString(buf[i] & 0xFF);
                    if (hex.length() == 1) {
                            hex = '0' + hex;
                    }
                    sb.append(hex.toUpperCase());
            }
            return sb.toString();
    }
    
    /**将16进制转换为二进制
     * @param hexStr
     * @return
     */
    public static byte[] parseHexStr2Byte(String hexStr) {
            if (hexStr.length() < 1)
                    return null;
            byte[] result = new byte[hexStr.length()/2];
            for (int i = 0;i< hexStr.length()/2; i++) {
                    int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);
                    int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);
                    result[i] = (byte) (high * 16 + low);
            }
            return result;
    }
    
    private static long ENCRYPT_KEY_1  = 0x7FBC02F1;
    private static long ENCRYPT_KEY_2 = 0x5B534F31;
    private static long ENCRYPT_KEY_3 = 0x52847605;
    
    @SuppressWarnings("unused")
	private static byte[] GenerateKey(long key){
    	byte[] keyBlock = new byte[16];
        keyBlock[0] = (byte)(((key >> 24) & 0xF0) | ((ENCRYPT_KEY_1 >> 28) & 0x0F));
        keyBlock[1] = (byte)(((key >> 20) & 0xF0) | ((ENCRYPT_KEY_1 >> 24) & 0x0F));
        keyBlock[2] = (byte)(((key >> 16) & 0xF0) | ((ENCRYPT_KEY_1 >> 20) & 0x0F));
        keyBlock[3] = (byte)(((key >> 12) & 0xF0) | ((ENCRYPT_KEY_1 >> 16) & 0x0F));
        keyBlock[4] = (byte)(((key >>  8) & 0xF0) | ((ENCRYPT_KEY_1 >> 12) & 0x0F));
        keyBlock[5] = (byte)(((key >>  4) & 0xF0) | ((ENCRYPT_KEY_1 >>  8) & 0x0F));
        keyBlock[6] = (byte)(((key >>  0) & 0xF0) | ((ENCRYPT_KEY_1 >>  4) & 0x0F));
        keyBlock[7] = (byte)(((key <<  4) & 0xF0) | ((ENCRYPT_KEY_1 >>  0) & 0x0F));

        keyBlock[8] = (byte)(((ENCRYPT_KEY_2 >> 24) & 0xF0) | ((ENCRYPT_KEY_3 >> 28) & 0x0F));
        keyBlock[9] = (byte)(((ENCRYPT_KEY_2 >> 20) & 0xF0) | ((ENCRYPT_KEY_3 >> 24) & 0x0F));
        keyBlock[10] = (byte)(((ENCRYPT_KEY_2 >> 16) & 0xF0) | ((ENCRYPT_KEY_3 >> 20) & 0x0F));
        keyBlock[11] = (byte)(((ENCRYPT_KEY_2 >> 12) & 0xF0) | ((ENCRYPT_KEY_3 >> 16) & 0x0F));
        keyBlock[12] = (byte)(((ENCRYPT_KEY_2 >> 8) & 0xF0) | ((ENCRYPT_KEY_3 >> 12) & 0x0F));
        keyBlock[13] = (byte)(((ENCRYPT_KEY_2 >> 4) & 0xF0) | ((ENCRYPT_KEY_3 >> 8) & 0x0F));
        keyBlock[14] = (byte)(((ENCRYPT_KEY_2 >> 0) & 0xF0) | ((ENCRYPT_KEY_3 >> 4) & 0x0F));
        keyBlock[15] = (byte)(((ENCRYPT_KEY_2 << 4) & 0xF0) | ((ENCRYPT_KEY_3 >> 0) & 0x0F));
        
        return keyBlock;
    }
    
    @SuppressWarnings("unused")
	private static YMD MJD2YMD( int MJD)
    {
    	int K;
    	YMD ymd = new YMD();
    	
    	ymd.Year = (int)((MJD - 15078.2)/365.25);
    	ymd.Month = (int)((MJD - 14956.1 - (int)(ymd.Year *365.25))/30.6001);
    	ymd.Day = MJD - 14956 - (int)(ymd.Year * 365.25) - (int)(ymd.Month * 30.6001);
    	if (( ymd.Month == 14 ) || ( ymd.Month == 15 ))
    	{
    		K = 1;
    	}
    	else
    	{
    		K = 0;
    	}
    	ymd.Year += K;
    	ymd.Year += 1900;
    	ymd.Month = ymd.Month - 1 - K * 12;
    	ymd.WD = ((MJD+2)%7)+1;
    	return ymd;
    }
    
    public static int getUnsignedByte (byte data){      //将data字节型数据转换为0~255 (0xFF 即BYTE)。
    	return data&0x0FF;
    }

    public static long getUnsignedIntt (byte data){      //将data字节型数据转换为0~255 (0xFF 即BYTE)。
    	return data&0x0FF;
    }    
    public static String byte2Hex(byte[] b) 
    { 
    	String hs = ""; String stmp  = ""; 
	    for (int n = 0; n < b.length; n++) 
	    { stmp = (java.lang.Integer.toHexString(b[n] & 0XFF)); 
	    if(stmp.length() == 1) { hs = hs + "0" + stmp; 
	    }else{hs=hs+stmp;}
	    }
	    return hs.toUpperCase();
    }
    public static byte[] hex2Byte(String str) {
		if (str == null)
			return null;
		str = str.trim();
		int len = str.length();
		//System.out.println("----------lenth:" +len);
		if (len == 0 || len % 2 == 1)
			return null;
		//System.out.println("11111111111111111111111111111111");
		byte[] b = new byte[len / 2];
		try {
			for (int i = 0; i < str.length(); i += 2) {
				b[i / 2] = (byte) Integer
						.decode("0x" + str.substring(i, i + 2)).intValue();
			}
			return b;
		} catch (Exception e) {
			return null;
		}
	}
}
